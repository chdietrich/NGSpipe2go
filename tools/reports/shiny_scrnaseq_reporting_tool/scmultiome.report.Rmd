---
title: "SHINYREPS_PROJECT"
output:
  html_document:
    toc: true
    toc_float: true
    css: styles.css
---

<div class="contentbox">





# Description

Enter project description here


# Processing

Enter pipeline description here.


```{r setup, echo=F, result='hide', error=F, warning=F, message=F}

# source helper functions
source("sc.shinyrep.helpers.R")


# load required packages
not_yet_attached <- attach_packages(c("tidyverse", "AnnotationDbi", "batchelor", "Biobase", "BiocSingular", "bluster", 
          "Cairo", "circlize", "chromVAR", "cluster", "ComplexHeatmap", "corrplot", "data.table", "dendextend", "DropletUtils", 
          "future", "GeneOverlap", "ggbeeswarm", "ggrepel", "gplots", "grid", "gridExtra", "igraph", "JASPAR2020", 
          "knitr", "kableExtra", "limma", "M3Drop", "Matrix", "parallel", "pbapply", "pheatmap", "pkgmaker", "plotly", "png", 
          "RColorBrewer", "reshape2", "rmarkdown", "rtracklayer", "Rtsne", "scales", "scater", "scDblFinder", "scran", "scuttle", 
          "Seurat", "SeuratDisk", "Signac", "shinydashboard", "TFBSTools", "uwot", "VennDiagram", "vipor", "viridis", "zellkonverter"))



# load global variables
loadGlobalVars(f="shinyReports.txt")

# load relevant BSgenome package (needed by Signac for motif analysis)
failed_BSgenome <- c("")
switch(SHINYREPS_DB,
    hg38={ failed_BSgenome <- attach_packages("BSgenome.Hsapiens.UCSC.hg38") },
    mm10={ failed_BSgenome <- attach_packages("BSgenome.Mmusculus.UCSC.mm10") },
    stop(c("Don't find genome:", SHINYREPS_DB))   
)
not_yet_attached <- c(not_yet_attached, failed_BSgenome)

# create folder for output files
if (!file.exists(file.path("report_files"))) {dir.create(file.path("report_files"))}

# set options
options(stringsAsFactors=FALSE)
CORES <- 2
pal   <- brewer.pal(9, "Set1")
pal_rb <- colorRampPalette(c(pal[1], "white", pal[2]))(20)
pal_y  <- colorRampPalette(c("black", "yellow"))(100)
plot_pointsize <- 1 # point size for plotReducedDim plots

knitr::opts_chunk$set(cache=F,
                      echo=F,
                      warning=F,
                      message=F,
                      dev='CairoPNG')

theme_set(theme_bw() + theme(axis.text=element_text(colour="grey30",size=12),
									axis.title=element_text(colour="grey30",size=14),
									plot.title=element_text(size=14,hjust=0.5),
									plot.subtitle=element_text(size=12,hjust=0.5),
									legend.text=element_text(size=12,colour="grey30"),
									legend.title=element_text(size=12,colour="grey30")))

# load list of mitochondrial genes (if not given, we will use all genes starting with "MT-")
mito.genes <- if(file.exists(file.path(SHINYREPS_PROJECT,SHINYREPS_MTGENES))) {
  read.delim(file.path(SHINYREPS_PROJECT,SHINYREPS_MTGENES))[, 1]
} else {NA}

runCutadapt <- SHINYREPS_RUN_CUTADAPT=="true" # check for selected pipeline modules 
org <- SHINYREPS_ORG # organism name needed for cell cycle and GO enrichment 
selgenes <- c("") # selected genes (symbols) for expression plots

if (F) { # old part
## load or create specific targets file for all cells. Accomodates both 10X ATAC-seq & 10X Multiome ATAC component
#Columns required: "sample_id", "molecule_h5"
targets_pools <- read.delim(SHINYREPS_TARGET, sep="\t")
cellranger_dir <- file.path(SHINYREPS_RES, SHINYREPS_CELLRANGERAGGR_ID, "outs")
matrix_dir <- file.path(cellranger_dir, "filtered_peak_bc_matrix")                                    # 10X ATAC
if (!dir.exists(matrix_dir)) {matrix_dir <- file.path(cellranger_dir, "filtered_feature_bc_matrix")}  # 10X Multiome
targets = read.delim(file.path(matrix_dir, "barcodes.tsv.gz"), header = FALSE, stringsAsFactors = FALSE)
names(targets) = "cell_id"
targets <- cbind(targets, targets_pools[as.numeric(gsub("^.*-", "", targets$cell_id)),])
rownames(targets) <- targets$cell_id

group.vars <- colnames(targets)[!colnames(targets) %in% c("cell_id", "sample", "file")] 
targets[,group.vars] <- lapply(targets[,group.vars], factor)
group.vars <- group.vars[sapply(group.vars, function(x) {length(unique(targets[,x]))>1})] # remove group vars with single value
targets4plots <- targets_pools
colorByFactor <- "sample" # default for pipeline overview plots
colorByFactor2 <- if(!is.na(SHINYREPS_COLORBYFACTOR)) {SHINYREPS_COLORBYFACTOR} else {"sample"} # default for downstream plots (up to 2 categories)
}

      aggrcsv <- read.delim(file.path(SHINYREPS_RES, "aggr.csv"), sep=",") # aggr.csv contains the order of GEM wells
      # load targets.txt (data per fastq file). Columns required: "sample", "file", "group", "replicate"
      targets_pools <- read.delim(SHINYREPS_TARGET, sep="\t", comment.char = "#")
      # create targets on cell level
      cellranger_dir <- file.path(SHINYREPS_RES, SHINYREPS_CELLRANGERAGGR_ID, "outs")
      matrix_dir <- file.path(cellranger_dir, "filtered_peak_bc_matrix")                                    # 10X ATAC
      # matrix_dir = file.path(SHINYREPS_RES, SHINYREPS_CELLRANGERAGGR_ID, "outs/count/filtered_feature_bc_matrix/") # 10X GEX
      if (!dir.exists(matrix_dir)) {matrix_dir <- file.path(cellranger_dir, "filtered_feature_bc_matrix")}  # 10X Multiome
      targets = read.delim(file.path(matrix_dir, "barcodes.tsv.gz"), header = FALSE, stringsAsFactors = FALSE)
      names(targets) = "cell_id"
      
      if(!is.na(SHINYREPS_RUN_DEMUX)) { # sample multiplexing applied?
        
        if(SHINYREPS_RUN_DEMUX=="demux_HTO") { # add HTO information if cell hashing applied
          demuxfiles <- lapply(1:nrow(aggrcsv), function(x) {
            read.delim(file.path(SHINYREPS_DEMUX_OUT, gsub("_S._L..._R._001", "", aggrcsv$library_id)[x], "Seurat", "demux.txt"), sep="\t")
          })
          demuxfiles <- dplyr::bind_rows(demuxfiles, .id = "GEMwell")
          demuxfiles$cell_id <- paste(demuxfiles$cell_id, demuxfiles$GEMwell, sep="-")
          targets <- merge(targets, demuxfiles[, c("cell_id", "GEMwell", "HTO_maxID", "HTO_classification.global", 
                                                    "nCount_HTO", "nFeature_HTO", "HTO_secondID", "HTO_margin")], by="cell_id")
          targets$name_HTO <- gsub("-.*$", "", targets$HTO_maxID)
        }
        
        if(SHINYREPS_RUN_DEMUX=="demux_GT") { # add information if sample multiplexing by genetic variance is applied

          # load assignSouporcellCluster files to correlate cluster among samples
          clusterassignFilenames <- list.files(SHINYREPS_DEMUXCLUSTER_OUT, pattern = "\\.txt$", full.names=T)
          clusterassign <- lapply(clusterassignFilenames, read.delim, sep="\t", skip=5)
          clustercount  <- as.numeric(gsub("clusters for experiment1 ", "", sapply(clusterassignFilenames, read.delim, skip=2, nrows=1)))
          names(clusterassign) <- names(clustercount) <- gsub("\\.txt$", "", basename(clusterassignFilenames))
          for (i in names(clusterassign)) {
            colnames(clusterassign[[i]])[1:2] <- unlist(strsplit(i, split="_vs_"))
            clusterassign[[i]] <- clusterassign[[i]][1:clustercount[i],1:2]
          }

          # load demux_GT files in order defined in aggrcsv
          aggrcsvPrunedSampleId <- gsub("_S._L..._R._001", "", aggrcsv$library_id)
          demuxfiles <- lapply(1:nrow(aggrcsv), function(x) { # files loaded in order defined in aggrcsv
            read.delim(file.path(SHINYREPS_DEMUX_OUT, aggrcsvPrunedSampleId[x], "clusters.tsv"), sep="\t")
          })
          
          # print table with status column later
          overviewStatus <- sapply(demuxfiles, function(x) table(x$status))
          colnames(overviewStatus) <- aggrcsvPrunedSampleId
          overviewStatus <- as.data.frame(dplyr::bind_rows(as.data.frame(overviewStatus), .id = "file")) ########### CHECK WHAT's WRONG

          # continue with singlets only
          demuxfiles <- lapply(demuxfiles, function(x) {
             x <- x[x$status=="singlet",]
             x$subsample <- x$assignment # column used for re-assignment of souporcell clusters
             return(x)})

          # Replace cluster assignments for all samples in demuxfiles except for the first one which is used as reference
          for (j in 2:length(aggrcsvPrunedSampleId)) {
            clusterassignCurrent <- names(clusterassign)[grepl(aggrcsvPrunedSampleId[1], names(clusterassign)) & grepl(aggrcsvPrunedSampleId[j], names(clusterassign))]
            newValues <- clusterassign[[clusterassignCurrent]][,aggrcsvPrunedSampleId[1]]
            oldValues <- clusterassign[[clusterassignCurrent]][,aggrcsvPrunedSampleId[j]]
            demuxfiles[[j]]$subsample <- plyr::mapvalues(demuxfiles[[j]]$assignment, from=oldValues, to=newValues) # new column with adjusted assignment
          }

          # bind rows to single dataframe and filter cell ids by merging with targets
          demuxfiles <- dplyr::bind_rows(demuxfiles, .id = "GEMwell")
          demuxfiles$cell_id <- paste(gsub("-.$", "", demuxfiles$barcode), demuxfiles$GEMwell, sep="-")
          targets <- merge(targets, demuxfiles[, c("cell_id", "GEMwell", "subsample", "assignment", "status", "log_prob_singleton", "log_prob_doublet")], by="cell_id")
          
          # If subsample column in targets.txt is not pre-defined by user, it is automatically generated.
          # This is used for merging targets with targets_pools to link the cell barcodes with sample names
          # but note that in that case the assignment of subsamples to the sample ids in targets_pools is arbitrary 
          # (need external genetic information for specific assignment).
          if(is.null(targets_pools$subsample) || all(is.na(targets_pools$subsample))) {
            targets_pools <- targets_pools %>% dplyr::group_by(file)  %>%
                dplyr::mutate(subsample = 0:(dplyr::n_distinct(sample)-1)) %>% # enumerate samples per file (start with 0)
                dplyr::ungroup() %>%
                as.data.frame()
          }
        }
    }
     
      # merge targets with targets_pools and sort 
      # ensure that GEM wells merged in aggr module are assigned the sample names from targets.txt in correct order
      # the -digit suffix of the cell barcode reflects the order that the GEM wells were provided in the aggr.csv
      targets$file <- gsub("_S._L..._R._001", "", aggrcsv[as.numeric(gsub("^.*-", "", targets$cell_id)), "library_id"])
      targets_pools$file <- gsub("(_S.)*(_L...)*(_R.)*(_001)*", "", targets_pools$file) # in case file name was partly pruned in targets_pools
      targets <- merge(targets, targets_pools) # if "name_HTO" column is present in targets, it is used for merging as well (unmapped cells discarded)
      rownames(targets) <- targets$cell_id
      StartingColumnNames <- c("cell_id", "sample", "file", "group", "replicate")
      targets <- targets[order(targets$sample, targets$cell_id), c(StartingColumnNames, colnames(targets)[!colnames(targets) %in% StartingColumnNames])]
      
      # define group.vars
      demux_columns <- c("assignment", "status", "log_prob_singleton", "log_prob_doublet",
                         "GEMwell","HTO_maxID","nCount_HTO","HTO_secondID", "HTO_margin", "file_HTO","seq_HTO")
      group.vars <- colnames(targets)[!colnames(targets) %in% c("cell_id", "sample", "file", demux_columns)] 
      targets[,group.vars] <- lapply(targets[,group.vars], factor)
      group.vars <- group.vars[sapply(group.vars, function(x) {length(unique(targets[,x]))>1})] # remove group vars with single value
      # in case of hto multiplexing targets_pools is collapsed to (not de-multiplexed) fastq files for the fastq-file level QC plots (targets4plots).
      # But 'group' and 'replicate' columns are not kept if they show multiple values per file (e.g. multiplexed samples belong to different groups). 
      # This is only relevant for the gene body coverage plots per group or per replicate, which would be misleading in that case.
      collapsedColumns <- sapply(c("sample", "group", "replicate"), function(x) {
          all(sapply(unique(targets_pools$file), function(y) {length(unique(targets_pools[targets_pools$file==y, x]))==1}))
          })
      targets4plots <- targets_pools[!duplicated(targets_pools$file), c("file", names(collapsedColumns)[collapsedColumns])] 
      if(!"sample" %in% colnames(targets4plots)) {targets4plots$sample <- targets4plots$file} # "sample" column is needed. Same as "file" if ambiguous.
      colorByFactor <- "sample" # default for pipeline overview plots on file level
      colorByFactor2 <- if(!is.na(SHINYREPS_COLORBYFACTOR)) {SHINYREPS_COLORBYFACTOR} else {"sample"} # default for downstream plots on cell level (up to 2 categories)


# print targets file
DT::datatable(targets, caption="targets file (sample sheet) used for analysis")
```

```{r read_annotation}
# load gene annotation provided in essential.vars.groovy
gtf <- import.gff(SHINYREPS_GTF, format="gtf") # , feature.type="exon"

# Signac requires 'gene_biotype' field in annotation GTF, 10X (GENCODE) uses 'gene_type'
if ("gene_type" %in% colnames(mcols(gtf))) {
  gtf$gene_biotype <- gtf$gene_type
}

# Other changes necessary for Signac to properly parse the 10X GTF
genome(gtf) <- SHINYREPS_DB
seqlevelsStyle(gtf) <- "UCSC"
gtf <- keepStandardChromosomes(gtf, pruning.mode = "coarse")

names(gtf) <- gtf$gene_name

```


# Raw reads QC #

## FastQC of all reads

The raw sequence reads of all samples are analysed with the popular FastQC tool (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

#### Read quality

The "read qualities" plot summarizes the mean quality score at each position.
The color on the graph shows the Phred quality scores, which are logarithmically related to the base-calling error probabilities. The higher the score the better the base call. The background of the graph divides the y axis into very good quality calls (green), calls of reasonable quality (yellow), and calls of poor quality (red). Typically, the majority of calls on all base positions fall into the green area. Due to binning of quality score in recent sequencing technologies (e.g. Illumina NextSeq), sequencing qualities are the same on many position and, thus, also samples appear to have very similar or almost identical sequencing qualities.


```{r FastQC_qual_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}
##### parameters to set:
# Select samples for which you would like to include fastqc results in the report. For single cell RNA-Seq with many cells, 
# you may want to restrict the total number of plots. If you provide a regular expression in 'samplePattern' only those 
# filenames will be included which match this expression, e.g. setting samplePattern="R1" yields only those fastq 
# files containing read1 of a read pair. This is recommended e.g. for MARS-Seq, where Read2 contains barcode information only.
# If you want to exclude samples according to the given certain pattern, define it in excludePattern. 
# If you set argument 'maxno', the maximum sample number will be restricted accordingly to the first 'maxno' plots. 
##### 

if (SHINYREPS_FASTQC_SUMMARIZED) {
    fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
} else {
    fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
}

```

```{r FastQC_qual, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1)}
# REMARK: the maximal figure height is limited to 170 and will throw an error if exceeded ("Failed to create Cairo backend!"). For the not summarized plots you should limit the number of plots to 200 by using the maxno parameter. Otherwise the plots will be squeezed.

if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
}

```

#### Sequence bias

The "sequence bias" plot shows the proportion of each base (% G, A, T and C) at each position. In a random library there would be little difference between the positions of a sequence run, so the lines in this plot should run parallel with each other. But most RNA-seq libraries show sequence imbalance in the first 10-12 read positions due to RT priming biases, which should however look fairly similar in all samples. In case the nucleotide content is summarized in a heatmap for all samples, gray colored fields represent a balanced nucleotide content.

```{r FastQC_nuc_content_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, ceiling(0.12*fastqc_summary_plot$no.of.samples)+1)}

if (SHINYREPS_FASTQC_SUMMARIZED) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
} 

```

```{r FastQC_nuc_content, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1)}

if (SHINYREPS_FASTQC_SUMMARIZED == F) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
}
```

#### GC content

The "GC content" plot shows the GC% distribution of all reads and all samples. Typically, the lines should tightly overlap and look essentially the same in all samples. An unusually shaped distribution could indicate a contaminated library.

```{r FastQC_GC, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}

fastqc_summary_plot$p.gc
cat("\n", fill = T)
```



```{r cutadapt, echo=F, results='asis', error=F, warning=F, message=F, eval=runCutadapt}
##### parameters to set:
# define subset of cutadapt log files if desired (samplePattern=NULL (default) includes all files).
# define categories of targets.txt to be used for dot color in the plot (one plot per element of colorByFactor will be created). 
# The function will try to map the data from targets$file to the cutadapt log file names (for this, the unique part of 
# targets$file must be a substring of file name). If you have cutadapt log files from pooled fastq files but cell-wise 
# information in targets.txt as in MARS-Seq, you may provide another customized targets object in 'targetsdf'. 
# Otherwise pruned file names will be used by default.
#####

if(runCutadapt) {
  cat("## Adapter trimming with Cutadapt\n")
  
  cat("\nThe following plot shows the amount of reads trimmed for the selected adapter sequences including polyA/polyT sequences if specified. The column 'tooshort' gives the percentage of reads removed due to a length of less than 30 bases after trimming. Additionally to the column 'trimmed' which is for all adapters combined, there are columns for every single adapter giving the percentage of reads trimmed for this adapter.\n\n")
  
  DEhelper.cutadapt(colorByFactor=colorByFactor, targetsdf=targets4plots)
}
```

```{r FastQC_qual_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=runCutadapt}
if(runCutadapt) {

  cat("### FastQC of trimmed reads QC\n\n")
  cat("#### Read quality\n\n")
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T, targetsdf=targets4plots, subdir="trimmed", samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
      plot(fastqc_summary_plot$p.qual)
      cat("\n", fill = T)
  } else {
      fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F, targetsdf=targets4plots, subdir="trimmed", samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
  }
}

```

```{r FastQC_qual_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=runCutadapt}
if(runCutadapt) {
  
  if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
      plot(fastqc_summary_plot$p.qual)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_nuc_content_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, ceiling(0.12*fastqc_summary_plot$no.of.samples)+1), eval=runCutadapt}

if(runCutadapt) {

  cat("#### Sequence bias of trimmed reads\n")
  
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_nuc_content_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=runCutadapt}
if(runCutadapt) {

  if (SHINYREPS_FASTQC_SUMMARIZED == F) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_GC_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=runCutadapt}
if(runCutadapt) {

  cat("#### GC content of trimmed reads\n")
  fastqc_summary_plot$p.gc
  cat("\n", fill = T)
}
```


# Mapping Statistics

```{r cellranger_mapping_stats, results='asis', message=FALSE, warning=FALSE, eval=nrow(targets)>100}

cat("\nMapping Statistics can be found in the cellranger web summary.\n")

```


## Competitive mapping to potential contaminants:

A competitive mapping to the reference genome and known rRNAs (H. sapiens, M. musculus, C. elegans, D. melanogaster, D. rerio, X. tropicalis) as well as frequently occurring Mycoplasma species (M. arginini, M. fermentans, M. hominis, M. hyorhinis, M. orale, and Acholeplasma laidlawii), PhiX and ERCC spike-in sequences, E. coli and B. taurus (bovine) was performed with FastQScreen (http://www.bioinformatics.babraham.ac.uk/projects/fastq_screen/).

In the following plot only relevant contaminants are shown. A contaminant is considered relevant if it consumes `r SHINYREPS_FASTQSCREEN_PERC`% of reads or more in at least one sample. The "one genome" label refers to the amount of reads mapping to that genome only, no matter if they are mapping uniquely or multiple times. The "multiple genome" label refers to the amount of read mapping to this genome but also to other genomes in the screening regardless of whether they are uniquely or multi mapping. 

```{r fastqscreen_paragraph, echo=F, results='asis', fig.width=10, error=F, warning=F, message=F}
fastqscreen_plots <- DEhelper.fastqscreen(perc.to.plot=SHINYREPS_FASTQSCREEN_PERC, ncol=3, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
```

```{r fastqscreen_paragraph2, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, (round((1.5*fastqscreen_plots$no.of.rows))+1)*fastqscreen_plots$no.of.samples/8+1)}
  if(is.null(fastqscreen_plots$errortext)) {
    plot(fastqscreen_plots$p.category.wrap)
    } else {
      cat(fastqscreen_plots$errortext)
      }
```




# Joint RNA and ATAC analysis

This processing pipeline is based mainly on the Signac vignettes from Stuart Lab:

* [Joint RNA and ATAC analysis](https://stuartlab.org/signac/articles/pbmc_multiomic.html)

`Signac` is an R package for single cell ATAC-seq analysis from the Satija lab [(Stuart et al., 2021)](https://doi.org/10.1038/s41592-021-01282-5). This is also the lab behind the popular single cell RNA-seq R package `Seurat` [(Stuart et al., 2019)](https://doi.org/10.1016/j.cell.2019.05.031).

The main `Signac` vignette overview page is at: [https://satijalab.org/signac/articles/overview.html](https://satijalab.org/signac/articles/overview.html)

Also useful is the main `Seurat` vignettes overview page, as Signac builds on Seurat: [https://satijalab.org/seurat/articles/get_started.html](https://satijalab.org/seurat/articles/get_started.html)




```{r Seurat_object, echo=F, message=FALSE, error=TRUE, warning=TRUE}

#############################
# load the RNA and ATAC data
counts <- Read10X_h5(file.path(cellranger_dir, "filtered_feature_bc_matrix.h5"))
fragpath <- file.path(cellranger_dir, "atac_fragments.tsv.gz")

# library(EnsDb.Hsapiens.v86)
# anno <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)
# seqlevelsStyle(annotation) <- "UCSC"

# filter out genes not annotated in gtf
genes.use <- rownames(counts$`Gene Expression`) %in% names(gtf)
counts$`Gene Expression` <- counts$`Gene Expression`[genes.use,]

# create a Seurat object containing the RNA adata
sobj <- CreateSeuratObject(
  counts = counts$`Gene Expression`,
#  annotation = gtf, # why no effect? Can't I load different anno for ATAC peaks?
  assay = "RNA"
)


# create ATAC assay and add it to the object
# blacklist_hg38_unified comes with Signac package
# we'll only use peaks in standard chromosomes and not overlapping with blacklisted regions
grange.counts <- StringToGRanges(rownames(counts$Peaks), sep = c(":", "-"))
grange.counts <- subsetByOverlaps(grange.counts, ranges = blacklist_hg38_unified, invert = TRUE) 
grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts)
counts$Peaks <- counts$Peaks[as.vector(grange.use), ]

sobj[["ATAC"]] <- CreateChromatinAssay(
  counts = counts$Peaks, # creates matrix with read counts not fragments
  sep = c(":", "-"),
  fragments = fragpath,
  annotation = gtf # 
)


if(!all(rownames(targets) %in% colnames(sobj))) {stop("There are cells in your targets list which are not in the Seurat object!")}
#table(colnames(sobj) %in% rownames(targets))

sobj <- sobj[,colnames(sobj) %in% rownames(targets)]
targets <- targets[match(colnames(sobj), rownames(targets)),]

#sobj <- AddMetaData(object = sobj, metadata = targets$sample, col.name = 'sample')
sobj <- AddMetaData(
  object = sobj,
  metadata = targets
)


# Add fragment counts (e.g. for counting reads in peaks)
total_fragments <- CountFragments(fragpath)
rownames(total_fragments) <- total_fragments$CB
sobj$fragments <- total_fragments[colnames(sobj), "frequency_count"]

# The previous commands create large temporary objects, give memory back to OS
gc()


```





```{r new_peak_calling, echo=F, message=FALSE, error=TRUE, warning=TRUE, eval=F}
if(F) {
cat("## Peak calling\n\n")
  
cat("\nThe set of peaks identified using Cellranger often merges distinct peaks that are close together. This can create a problem for certain analyses, particularly motif enrichment analysis and peak-to-gene linkage. To identify a more accurate set of peaks, we can call peaks using MACS2 with the CallPeaks() function. Here we call peaks on all cells together, but we could identify peaks for each group of cells separately by setting the group.by parameter, and this can help identify peaks specific to rare cell populations.\n")

# call peaks using MACS2
peaks <- CallPeaks(sobj, assay = "ATAC", group.by="sample") 

# remove peaks on nonstandard chromosomes and in genomic blacklist regions
# blacklist_hg38_unified comes with Signac package
peaks <- keepStandardChromosomes(peaks, pruning.mode = "coarse")
peaks <- subsetByOverlaps(x = peaks, ranges = blacklist_hg38_unified, invert = TRUE) 

# quantify counts in each peak
macs2_counts <- FeatureMatrix(
  fragments = Fragments(sobj),
  features = peaks,
  cells = colnames(sobj)
)

# create a new assay using the MACS2 peak set and add it to the Seurat object
sobj[["peaks"]] <- CreateChromatinAssay(
  counts = macs2_counts,
  fragments = fragpath,
  annotation = gtf 
)
}

```




## Quality control

We can compute per-cell quality control metrics using the DNA accessibility data and remove cells that are outliers for these metrics, as well as cells with low or unusually high counts for either the RNA or ATAC assay.

```{r qc, echo=F, message=FALSE, error=TRUE, warning=TRUE}

DefaultAssay(sobj) <- "ATAC"

# compute nucleosome signal score per cell
sobj <- NucleosomeSignal(sobj)
# compute TSS enrichment score per cell
sobj <- TSSEnrichment(sobj, fast = FALSE)

# count reads in peaks
sobj <- FRiP(sobj, assay = 'ATAC', total.fragments = 'fragments')

# count reads in blacklisted regions
sobj$blacklist_fraction <- FractionCountsInRegion(sobj, assay = 'ATAC', regions = blacklist_hg38_unified)

# add blacklist ratio and fraction of reads in peaks
#sobj$pct_reads_in_peaks <- sobj$peak_region_fragments / sobj$passed_filters * 100
#sobj$blacklist_ratio <- sobj$blacklist_region_fragments / sobj$peak_region_fragments

```


### Nucleosome signal

The histogram of DNA fragment sizes (determined from the paired-end sequencing reads) should exhibit a strong nucleosome banding pattern corresponding to the length of DNA wrapped around a single nucleosome. We calculate this per single cell, and quantify the approximate ratio of mononucleosomal to nucleosome-free fragments.

```{r atac_qc_nucleosome_signal}


p <- FragmentHistogram(object = sobj, group.by = 'sample', region = 'chr1-1-10000000') +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("Fragment size histograms") +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_qc_fragmentsizes_hist.pdf", height = 6, width = 6)
print(p)

```


### TSS enrichment

Transcriptional start site (TSS) enrichment score. The ENCODE project has defined an ATAC-seq targeting score based on the ratio of fragments centered at the TSS to fragments in TSS-flanking regions (see https://www.encodeproject.org/data-standards/terms/). Poor ATAC-seq experiments typically will have a low TSS enrichment score.

```{r atac_qc_tss_enrichment}

p <- TSSPlot(sobj, group.by = 'sample') +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("Fragment enrichment at TSS") +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_qc_tss_enrich_profiles.pdf", height = 6, width = 6)
print(p)

if(F) {
## Split according to score threshold; compare different thresholds

sobj$high.tss <- ifelse(sobj$TSS.enrichment > 2, 'High', 'Low')
p <- TSSPlot(sobj, group.by = 'high.tss') +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("Fragment enrichment at TSS (threshold = 2)") +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_qc_tss_enrich_profiles_hightss20.pdf", height = 6, width = 6)
print(p)

sobj$high.tss <- ifelse(sobj$TSS.enrichment > 2.5, 'High', 'Low')
p <- TSSPlot(sobj, group.by = 'high.tss') +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("Fragment enrichment at TSS (threshold = 2.5)") +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_qc_tss_enrich_profiles_hightss25.pdf", height = 6, width = 6)
print(p)

sobj$high.tss <- ifelse(sobj$TSS.enrichment > 3, 'High', 'Low')
p <- TSSPlot(sobj, group.by = 'high.tss') +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("Fragment enrichment at TSS (threshold = 3)") +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_qc_tss_enrich_profiles_hightss30.pdf", height = 6, width = 6)
print(p)
}

```

Read counts per cell in RNA and ATAC experiment (nCount_RNA, nCount_ATAC): A measure of cellular sequencing depth / complexity. Cells with very few reads may need to be excluded due to low sequencing depth. Cells with extremely high levels may represent doublets, nuclei clumps, or other artefacts.


```{r qc_vlnplot, echo=F, message=FALSE, error=TRUE, warning=TRUE}

VlnPlot(
  object = sobj,
  features = c("nCount_RNA", "nCount_ATAC", "FRiP", "blacklist_fraction", "TSS.enrichment", "nucleosome_signal"),
  ncol = 3,
  pt.size = 0,
  group.by="sample"
)


```


### Filter for QC thresholds

Applied filter criteria:

* nCount_ATAC > 1000 & nCount_ATAC < 50000 and 

* nCount_RNA > 1000 & nCount_RNA < 30000 and 

* Fraction of reads in peaks > 0.3 and

* Fraction of reads in blacklisted regions < 0.05 and

* nucleosome_signal < 2 and

* TSS.enrichment > 1



```{r qc_filter, echo=F, message=FALSE, error=TRUE, warning=TRUE}

sobj <- subset(
  sobj,
  subset = nCount_ATAC > 1000 & nCount_ATAC < 50000 & 
    nCount_RNA > 1000 & nCount_RNA < 30000 &
    FRiP > 0.3 & blacklist_fraction < 0.05 &
    nucleosome_signal < 2 & TSS.enrichment > 1
)

VlnPlot(
  object = sobj,
  features = c("nCount_RNA", "nCount_ATAC", "FRiP", "blacklist_fraction", "TSS.enrichment", "nucleosome_signal"),
  ncol = 3,
  pt.size = 0,
  group.by="sample"
)


```



Read Peak motifs and Peak-to-peak and peak-to-gene co-activity correlation data (feature linkage).

Note that the motif detection and feature linkage can also be performed using `Signac`. This would be required if custom peak calling is done, rather than using Cell Ranger's peaks. More information on this can be found in the [Signac multiomic vignette](https://satijalab.org/signac/articles/pbmc_multiomic.html).


```{r motifs, echo=F, message=FALSE, error=TRUE, warning=TRUE, eval=T}

  peaks.path <- file.path(cellranger_dir, "atac_peaks.bed")
  peak_annotation.path <- file.path(cellranger_dir, "atac_peak_annotation.tsv")
  tf_barcodes.path <- file.path(cellranger_dir, "analysis/tf_analysis/filtered_tf_bc_matrix/barcodes.tsv.gz")
  tf_motifs.path <- file.path(cellranger_dir, "analysis/tf_analysis/filtered_tf_bc_matrix/motifs.tsv")
  tf_matrix.path <- file.path(cellranger_dir, "analysis/tf_analysis/filtered_tf_bc_matrix/matrix.mtx.gz")

## Cell-to-motif score matrix

motif_counts <- readMM(file = tf_matrix.path)
colnames(motif_counts) <- read.delim(tf_barcodes.path, header = FALSE, stringsAsFactors = FALSE)$V1
motifs <- read.delim(tf_motifs.path, header = FALSE, stringsAsFactors = FALSE)
rownames(motif_counts) <- motifs$V1

# Filter for cells in both (previously processed & filtered) RNA & ATAC
shared_barcodes <- intersect(colnames(motif_counts), colnames(sobj))
motif_counts <- motif_counts[,shared_barcodes]


## Peak-to-motif mapping (10X Multiome only, even though it only uses ATAC data)
peaks2motifs.path <- file.path(cellranger_dir, "analysis/tf_analysis/peak_motif_mapping.bed")
peaks2motifs <- rtracklayer::import(peaks2motifs.path, format = "BED")


## Feature linkage data
feature_linkage.path <- file.path(cellranger_dir, "analysis/feature_linkage/feature_linkage.bedpe")
feature_linkage <- rtracklayer::import(feature_linkage.path, format = "BEDPE")
colnames(mcols(feature_linkage))[3:5] <- c("significance", "distance", "linkage_type")

write.table(as.data.frame(feature_linkage), file = file.path("report_files","Cellranger_feature_linkage.txt"), quote=F, sep = "\t", row.names = F)

```






## Gene expression data processing

We can normalize the gene expression data using SCTransform, and reduce the dimensionality using PCA.


```{r process_RNA, results=FALSE, echo=F, message=FALSE, error=TRUE, warning=TRUE}

DefaultAssay(sobj) <- "RNA"
sobj <- SCTransform(sobj)
sobj <- RunPCA(sobj)
sobj <- RunUMAP(sobj, dims = 1:50, reduction.name = 'umap.rna', reduction.key = 'rnaUMAP_')

```


## DNA accessibility data processing

Here we process the DNA accessibility assay the same way we would process a scATAC-seq dataset, by performing latent semantic indexing (LSI).

* Normalization: Signac performs term frequency-inverse document frequency (TF-IDF) normalization. This is a two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.

* Feature selection: The low dynamic range of scATAC-seq data makes it challenging to perform variable feature selection, as we do for scRNA-seq. Instead, we can choose to use only the top n% of features (peaks) for dimensional reduction, or remove features present in less than n cells with the FindTopFeatures() function. Here, we will all features, though we note that we see very similar results when using only a subset of features (try setting min.cutoff to ‘q75’ to use the top 25% all peaks), with faster runtimes. Features used for dimensional reduction are automatically set as VariableFeatures() for the Seurat object by this function.

* Dimension reduction: We next run singular value decomposition (SVD) on the TD-IDF matrix, using the features (peaks) selected above. This returns a reduced dimension representation of the object (for users who are more familiar with scRNA-seq, you can think of this as analogous to the output of PCA).


```{r DNA_accessibility, echo=F, message=FALSE, error=T, warning=T}

#DefaultAssay(sobj) <- "peaks"
DefaultAssay(sobj) <- "ATAC"

sobj <- RunTFIDF(sobj)                        # normalization
sobj <- FindTopFeatures(sobj, min.cutoff = 5) # feature selection (default 'q5')
sobj <- RunSVD(sobj)                          # dimensionality reduction (default n = 50)

```


Plot correlations of LSI components with read depth. The first LSI component often captures sequencing depth (technical variation) rather than biological variation. If we see a very strong correlation between the first LSI component and the total number of counts for the cell, this component should be removed from downstream analysis. 

```{r atac_plot_lsi_depth_corr, echo=F, message=F, error=F, warning=T}

p <- DepthCor(sobj) +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     theme(plot.subtitle=element_text(hjust=0.5)) +
     NoLegend()
ggsave(plot=p, filename = "report_files/atac_lsi_depth_corr_plot.pdf", height = 6, width = 6)
print(p)

sobj <- RunUMAP(sobj, reduction = 'lsi', dims = 2:50, reduction.name = "umap.atac", reduction.key = "atacUMAP_")
sobj <- RunTSNE(sobj, reduction = 'lsi', reduction.name = "tsne.atac", dims = 2:50)

```




## Joint UMAP visualization

Using the weighted nearest neighbor (WNN) methods in Seurat v4, we can compute a joint neighbor graph that represent both the gene expression and DNA accessibility measurements.

```{r wnn, echo=F, message=FALSE, error=TRUE, warning=TRUE}

# We calculate a WNN graph (Weighted Nearest Neighbor), representing a weighted combination of RNA and ATAC-seq modalities. 
# We use this graph for UMAP visualization and clustering.
# These will be stored in the neighbors slot, 
# and can be accessed using sobj[['weighted.nn']]
# The WNN graph can be accessed at sobj[["wknn"]], 
# and the SNN graph used for clustering at sobj[["wsnn"]]
# Cell-specific modality weights can be accessed at sobj$RNA.weight
sobj <- FindMultiModalNeighbors(
  object = sobj,
  k.nn =5, ###
  knn.range=5, ###
  reduction.list = list("pca", "lsi"), 
  dims.list = list(1:5, 2:40), ###
  modality.weight.name = "RNA.weight",
  verbose = TRUE
)

# build a joint UMAP visualization
sobj <- RunUMAP(
  object = sobj,
  nn.name = "weighted.nn",
  assay = "RNA",
  reduction.name = "umap.wnn",
  verbose = TRUE
)


# build a joint TSNE visualization
sobj <- RunTSNE(
  object = sobj,
  nn.name = "weighted.nn",
  assay = "RNA",
  reduction.name = "tsne.wnn",
  verbose = TRUE
)


# By default, cells are colored by their identity class (can be changed with the group.by parameter). 
umapSample <- DimPlot(sobj, label = TRUE, repel = TRUE, reduction = "umap.wnn", group.by = "sample") + ggtitle("WNN UMAP")
tsneSample <- DimPlot(sobj, label = TRUE, repel = TRUE, reduction = "tsne.wnn", group.by = "sample") + ggtitle("WNN TSNE")

ggsave(plot=umapSample, filename="report_files/umap_anno_sample.pdf")
ggsave(plot=tsneSample, filename="report_files/tsne_anno_sample.pdf")

```


```{r wnn_plot, echo=F, message=FALSE, error=F, warning=F}

patchwork::wrap_plots(umapSample, tsneSample, ncol = 2)

```


### WNN clustering

The calculated WNN graph is now used for clustering.

```{r WNNclustering, echo=F, message=FALSE, error=TRUE, warning=TRUE}

sobj <- FindClusters(sobj, graph.name = "wsnn", algorithm = 3, verbose = FALSE)

# Save clusters in a different metadata column, because it gets overwritten every time FindClusters is called
sobj$clusters_wnn <- sobj$seurat_clusters
# Also annotate nuclei with per-sample clusters
sobj$Sample_WNNClusters <- paste(sobj$sample, sobj$clusters_wnn, sep = "_")

WNNumap <- DimPlot(sobj, reduction = "umap.wnn", group.by = "clusters_wnn", label = TRUE, repel = TRUE) + ggtitle("WNN clustering")
ggsave(plot=WNNumap, filename="report_files/umap_anno_WNNcluster.pdf")
WNNumap

```


### ATAC data clustering

Cluster using the `FindNeighbors()` and `FindClusters()` functions from the `Seurat` package. Seurat's [FindClusters](https://satijalab.org/seurat/reference/findclusters) uses a graph clustering algorithm operating on the shared nearest neighbors (SNN) graph, with modularity detection.

Omit the first LSI component, which is anti-correlated with the read depth per nucleus.

```{r atac_clustering}

#DefaultAssay(sobj) <- "peaks"
DefaultAssay(sobj) <- "ATAC"

sobj <- FindNeighbors(object = sobj, reduction = 'lsi', dims = 2:50)
sobj <- FindClusters(object = sobj, verbose = FALSE, algorithm = 3)

# Save clusters in a different metadata column, because it gets overwritten every time FindClusters is called
sobj$clusters_atac <- sobj$seurat_clusters
# Also annotate nuclei with per-sample clusters
sobj$Sample_ATACClusters <- paste(sobj$sample, sobj$clusters_atac, sep = "_")
sobj$Group_ATACClusters <- paste(sobj$group, sobj$clusters_atac, sep = "_")

```

Plot UMAP colored by cluster and by sample.

```{r atac_umap_clusters}

Idents(sobj) <- "clusters_atac"

atacUmapCluster <- DimPlot(object = sobj, label = TRUE, reduction = "umap.atac") +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("ATAC UMAP by cluster") 
ggsave(plot=atacUmapCluster, filename = "report_files/atac_umap_plot_clusters.pdf", height = 9, width = 9)
#print(p)

Idents(sobj) <- "sample"

atacUmapSample <- DimPlot(object = sobj, label = FALSE, reduction = "umap.atac") +
     theme(plot.title=element_text(face="bold", hjust=0.5)) +
     ggtitle("ATAC UMAP by sample")
ggsave(plot=atacUmapSample, filename = "report_files/atac_umap_plot_samples.pdf", height = 9, width = 9)
#print(p)

patchwork::wrap_plots(atacUmapCluster, atacUmapSample, ncol = 2)

```


## Annotating cell types


### Anntotate with Seurat

To annotate cell types in the dataset we can transfer cell labels from an existing reference dataset using tools in the Seurat package. See the Seurat reference mapping vignette for more information.

```{r cell_types, fig.height=10, echo=F, message=FALSE, error=TRUE, warning=TRUE}


pathRefDataset <- file.path("/fsimb/groups/imb-bioinfocf/projects/cfb_internal/frank/multiome500/reference_data", "hcl.seurat.RDS") 
columnNameCelltypes <- "CT"
  
##################

# load reference data (must be SeuratObject)
cat("\nLoad reference dataset from", pathRefDataset, "with", columnNameCelltypes, "as cell type annotation column name.\n")
ref <- readRDS(file = file.path(pathRefDataset))
ref <- SCTransform(ref)
DefaultAssay(ref) <- "SCT"


DefaultAssay(sobj) <- "SCT"
# transfer cell type labels from reference to query
transfer_anchors <- FindTransferAnchors(
  reference = ref,
  query = sobj,
  normalization.method = "SCT",
  #reference.reduction = "spca",
  recompute.residuals = FALSE,
  dims = 1:30
)

predictions <- TransferData(
  anchorset = transfer_anchors, 
  refdata = ref[[]][columnNameCelltypes][,],
  weight.reduction = sobj[['pca']],
  dims = 1:30
)

sobj <- AddMetaData(
  object = sobj,
  metadata = predictions
) # cell annotation is stored in column 'predicted.id'


WNNumap_CT <- DimPlot(sobj, reduction = "umap.wnn", label = TRUE, repel = TRUE, group.by = 'predicted.id') + ggtitle("Celltype annotation")
ggsave(plot=WNNumap_CT, filename="report_files/umap_anno_CT.pdf")

patchwork::wrap_plots(WNNumap_CT, WNNumap, ncol = 1)

```


### Annotating cell types using Marker Genes

Using the [scType](https://github.com/IanevskiAleksandr/sc-type) tool we could perform the celltype annotation. This tool uses positive and negative marker genes to annotate a cluster to a specific celltype. The marker gene set includes data from the CellMarkerDB, PangaloDB and some additional manually curated gene (especially negative markers) from literature. This method currently seems to be better than any other competing tool, in terms of flexibility to use, speed, and accuracy (good performance even up-to 80% dropout rates on simulations) especially in identifying rare (but known) celltypes and distinguishing closely related celltypes. When a cluster contains scType score (which is used to annotate clusters) lower than one-fourth of the number of cells in the cluster the cluster is labelled as unknown. 

```{r cell_types_markerbased, fig.height=10, echo=F, message=FALSE, error=TRUE, warning=TRUE, eval=TRUE}

set.seed(100)
library(HGNChelper)
# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# DB file 
# TODO: This file can be provided in custom format, if we need to provide a different list of marker genes
# DB file should contain four columns (tissueType - tissue type, cellName - cell type, geneSymbolmore1 - positive marker genes, geneSymbolmore2 - marker genes not expected to be expressed by a cell type)
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

# TODO: Set this as a variable - an autodetect function is also available, perhaps it is safer to name it

tissue = "Brain" # e.g. Immune system,Pancreas,Liver,Eye,Kidney,Brain,Lung,Adrenal,Heart,Intestine,Muscle,Placenta,Spleen,Stomach,Thymus 
##################



# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)

# get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = sobj[["SCT"]]@scale.data, scaled = TRUE, 
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) 

# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. 
# In case Seurat is used, it is either pbmc[["RNA"]]@scale.data (default), pbmc[["SCT"]]@scale.data, in case sctransform is used for normalization,
# or pbmc[["integrated"]]@scale.data, in case a joint analysis of multiple single-cell datasets is performed.

# merge by cluster
cL_resutls = do.call("rbind", lapply(unique(sobj@meta.data$clusters_wnn), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(sobj@meta.data[sobj@meta.data$clusters_wnn==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(sobj@meta.data$clusters_wnn==cl)), 10)
}))
sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"
print(sctype_scores[,1:3])

sobj@meta.data$CTAnnotationSCType = "" # cell annotation is stored in column 'CTAnnotationSCType'
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  sobj@meta.data$CTAnnotationSCType[sobj@meta.data$clusters_wnn == j] = as.character(cl_type$type[1])
}

WNNumap_celltypeannot <- DimPlot(sobj, reduction = "umap.wnn", label = TRUE, repel = TRUE, group.by = 'CTAnnotationSCType') + ggtitle("Celltype anno based on WNN clustering")
ggsave(plot=WNNumap_celltypeannot, filename="report_files/umap_anno_WNNcluster_celltypeannotated.pdf")

patchwork::wrap_plots(WNNumap_celltypeannot, WNNumap, ncol = 1)


```


```{r pickCTanno, echo=F, message=FALSE, error=TRUE, warning=TRUE}
# select the cell type annotation to be used in downstream analysis
celltype <- "predicted.id" # select either "predicted.id" or "CTAnnotationSCType"
############


# set the cell identities to the cell type predictions for downstream analysis
Idents(sobj) <- celltype

CTselection <- c(predicted.id = "Anntotate with Seurat", CTAnnotationSCType = "Annotating cell types using Marker Genes")
cat(paste0("\nWe used the cell type annotation from section '", CTselection[celltype], "' for downstream analysis (i.e. annotation column '", celltype, "').\n"))

```





## Linking peaks to genes

For each gene, we can find the set of peaks that may regulate the gene by by computing the correlation between gene expression and accessibility at nearby peaks, and correcting for bias due to GC content, overall accessibility, and peak size. See the Signac paper for a full description of the method we use to link peaks to genes.

Running this step on the whole genome can be time consuming, so here we demonstrate peak-gene links for a subset of genes as an example. The same function can be used to find links for all genes by omitting the genes.use parameter:



```{r link_peaks2genes, echo=F, message=FALSE, error=TRUE, warning=TRUE}

#DefaultAssay(sobj) <- "peaks"
DefaultAssay(sobj) <- "ATAC"


# first compute the GC content for each peak
library(BSgenome.Hsapiens.UCSC.hg38)
sobj <- RegionStats(sobj, assay = "ATAC", genome = BSgenome.Hsapiens.UCSC.hg38)


sobj <- LinkPeaks(
  object = sobj,
  peak.assay = "ATAC",
  expression.assay = "SCT",
  genes.use = c("ACAP3", "HMCN1", "EVL", "EML1")
)

# access with Links(sobj)
write.table(as.data.frame(Links(sobj)), file="report_files/link_peaks2genes.txt", sep="\t", quote = F, row.names = F)

sobj@assays$ATAC@annotation$tx_id <- sobj@assays$ATAC@annotation$transcript_id


# We can visualize these links using the CoveragePlot() function, or alternatively we could use the CoverageBrowser() function in an interactive analysis.

# Plot frequency of Tn5 insertion events (accessibility) for different groups of cells within given regions of the genome. Tracks are normalized using a per-group scaling factor computed as the number of cells in the group multiplied by the mean sequencing depth for that group of cells. This accounts for differences in number of cells and potential differences in sequencing depth between groups. 
 
gene2plot <- "EVL"
p1 <- CoveragePlot(
  object = sobj,
  assay = "ATAC",
  region = gtf[gene2plot],
  features = gene2plot,
  expression.assay = "SCT",
  split.assays = T,
  links = T,
  annotation = "gene", 
  #region.highlight =StringToGRanges(gtf["ACAP3"]) ,
  # expression.assay = "RNA",
  # expression.slot     = "data",
  #idents = idents.plot,
  extend.upstream = 100000,
  extend.downstream = 100000
)

p2 <- CoveragePlot(
  object = sobj,
  region = gtf["HMCN1"],
  features = "HMCN1",
  expression.assay = "SCT",
  #idents = idents.plot,
  extend.upstream = 8000,
  extend.downstream = 5000
)

patchwork::wrap_plots(p1, p2, ncol = 1)

# Note that Cell Ranger ARC already does such peak-to-gene linking based on correlating peak accessibility to gene expression 
# (read in above into the `feature_linkage` object). This is the `Signac` version of the algorithm.
```






## Gene activity and peak co-accessibility network

Gene activity is the sum of the open chromatin signal associated with a particular gene. It allows converting the peak-level ATAC dat to gene-level ATAC data. This allows plotting gene-associated chromatin accessibility levels in the UMAP or t-SNE plots, and also mapping and/or merging different datasets (like scRNA-seq with scATAC-seq).

There are two approaches to this:

* Signac approach: This is a very simple approach that simply counts fragments in gene bodies and promoters.
* [Cicero approach](https://cole-trapnell-lab.github.io/cicero-release/docs_m3/#cicero-gene-activity-scores): This is more sophisticated and looks for correlations between accessible regions, including the gene promoters, across cells/nuclei.

Here we use the simple Signac approach.

```{r atac_gene_activity_signac, eval=FALSE}

gene.activities <- GeneActivity(sobj)

# Add the gene activity matrix to the Seurat object as a new assay and normalize it
sobj[['GeneActivities']] <- CreateAssayObject(counts = gene.activities)
sobj <- NormalizeData(
  object = sobj,
  assay = 'GeneActivities',
  normalization.method = 'LogNormalize',
  scale.factor = median(sobj$nCount_RNA)
)

saveRDS(gene.activities, file = file.path("report_files", "R_gene_activities.RDS"))
gc()

```

Plot gene activity of specific genes

```{r atac_plot_gene_activity_signac, eval=FALSE}

DefaultAssay(sobj) <- 'GeneActivities'

FeaturePlot(
  object = sobj,
  features = c('SYN1', 'CAMK2A', 'AQP4', 'OLIG1', 'PDGFRA', 'TMEM119'),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)

DefaultAssay(sobj) <- 'ATAC'

```


### Cicero peak co-accessibility network and gene activity (NOT YET IMPLEMENTED)

Here we use Cicero to calculate a cis-co-accessibility network (CCAN), and then to calculate gene activity scores based on it.

Cicero cis-co-accessibility network (CCAN). From [Signac Cicero vignette](https://satijalab.org/signac/articles/cicero.html)

```{r atac_cicero_ccan}


```

Cicero gene activities. From [Cicero website vignette](https://cole-trapnell-lab.github.io/cicero-release/docs_m3/#cicero-gene-activity-scores)

```{r atac_cicero_gene_activity}


```



## Differentially accessible peaks

Identify differentially accessible peaks between all pairs of groups for each cluster (see results in 'peaks_diffacces_clusters_atac.xlsx').

```{r atac_differentially_accessible_peaks, echo=F, message=FALSE, error=F, warning=F}

# differential accessibility between pairs of samples per calculated per cluster


ATAC_DA_MINCELLS <- 20        # minimum number of cells to include cluster in analysis

sobj$label <- sobj$Group_ATACClusters
Idents(sobj) <- "label"

grp_counts <- table(sobj$Group_ATACClusters)

sample_pairs <- combn(sort(unique(sobj$group)), 2)
da_groups_atac <- list()
for (cl in sort(unique(sobj$clusters_atac))) {
  for (sp in 1:ncol(sample_pairs)) {
    grp1 <- paste(sample_pairs[1, sp], cl, sep="_")
    grp2 <- paste(sample_pairs[2, sp], cl, sep="_")
    if (grp1 %in% names(grp_counts) && grp_counts[grp1] >= ATAC_DA_MINCELLS && 
        grp2 %in% names(grp_counts) && grp_counts[grp2] >= ATAC_DA_MINCELLS) {
      group_pair <- paste(grp1, grp2, sep = ".")
      cat("Processing pair: ", group_pair)
      da_groups_atac[[group_pair]] <- FindMarkers(
                                   object = sobj,
                                   ident.1 = grp1,
                                   ident.2 = grp2,
                                   min.pct = 0.05,
                                   test.use = 'LR',
                                   latent.vars = 'nFeature_ATAC'
                                 )
      cat(paste0(" (contains ", nrow(da_groups_atac[[group_pair]][da_groups_atac[[group_pair]]$p_val_adj < 0.05, ]), " peaks with adj p-val < 0.05)\n"))
    }
  }
}

# Save results
library(openxlsx)
if(length(da_groups_atac)>0) {
  openxlsx::write.xlsx(da_groups_atac, file = file.path("report_files", "peaks_diffacces_clusters_atac.xlsx"), rowNames=T)
  saveRDS(da_groups_atac, file = file.path("report_files", "R_merged_atac_da_clusters_atac.RDS"))
}
gc()



```



Identify differentially accessible peaks between all pairs of groups for each celltype (see results in 'peaks_diffacces_celltypes.xlsx').

```{r atac_differentially_accessible_peaks_by_celltype, echo=F, message=FALSE, error=F, warning=F}

## differential accessibility between pairs of samples per calculated per cluster

ATAC_DA_MINCELLS <- 20        # minimum number of cells to include cluster in analysis

sobj$Group_Celltypes <- paste(sobj$group, sobj[[celltype]][,1], sep = "_")
sobj$label <- sobj$Group_Celltypes
Idents(sobj) <- "label"

grp_counts <- table(sobj$Group_Celltypes)

sample_pairs <- combn(sort(unique(sobj$group)), 2)
da_groups_atac_ct <- list()
for (cl in sort(unique(sobj[[celltype]][,1]))) {
  for (sp in 1:ncol(sample_pairs)) {
    grp1 <- paste(sample_pairs[1, sp], cl, sep="_")
    grp2 <- paste(sample_pairs[2, sp], cl, sep="_")
    if (grp1 %in% names(grp_counts) && grp_counts[grp1] >= ATAC_DA_MINCELLS && 
        grp2 %in% names(grp_counts) && grp_counts[grp2] >= ATAC_DA_MINCELLS) {
      group_pair <- paste(grp1, grp2, sep = ".")
      cat("Processing pair: ", group_pair)
      da_groups_atac_ct[[group_pair]] <- FindMarkers(
                                   object = sobj,
                                   ident.1 = grp1,
                                   ident.2 = grp2,
                                   min.pct = 0.05,
                                   test.use = 'LR',
                                   latent.vars = 'nFeature_ATAC'
                                 )
      cat(paste0(" (contains ", nrow(da_groups_atac_ct[[group_pair]][da_groups_atac_ct[[group_pair]]$p_val_adj < 0.05, ]), " peaks with adj p-val < 0.05)\n"))
    }
  }
}

# Save results
library(openxlsx)
if(length(da_groups_atac_ct)>0) {
  names(da_groups_atac_ct) <- gsub("Proliferating cell", "Prolif", names(da_groups_atac_ct)) # sheetNames too long! Max length is 31 characters.
  names(da_groups_atac_ct) <- gsub("Oligodendrocyte", "ODC", names(da_groups_atac_ct))
  names(da_groups_atac_ct) <- gsub("Proliferating radial glia", "PRG", names(da_groups_atac_ct))
  names(da_groups_atac_ct) <- gsub("Radial glia", "RG", names(da_groups_atac_ct))
  openxlsx::write.xlsx(da_groups_atac_ct, file = file.path("report_files", "peaks_diffacces_celltypes.xlsx"), rowNames=T)
  saveRDS(da_groups_atac_ct, file = file.path("report_files", "R_merged_atac_da_celltypes.RDS"))
}
gc()


```




## Motif enrichment analysis

List of motifs is obtained from Bioconductors `JASPAR2020` package.

*Note: this code is human-specific, as it uses the `BSgenome.Hsapiens.UCSC.hg38` Bioconductor package*

```{r atac_motifs_setup, echo=F, message=FALSE, error=F, warning=F}

# Get a list of motif position frequency matrices from the JASPAR database
pfm <- TFBSTools::getMatrixSet(
  x = JASPAR2020,
  opts = list(collection = "CORE", tax_group = "vertebrates", all_versions = FALSE)
)

# sobj has data mapped to scaffolds named differently to the BSgenome. The scaffolds aren't that useful for analysis, so you could solve this by removing peaks that are on scaffolds.
main.chroms <- standardChromosomes(BSgenome.Hsapiens.UCSC.hg38)
keep.peaks <- which(as.character(seqnames(granges(sobj))) %in% main.chroms)
sobj[["ATAC"]] <- subset(sobj[["ATAC"]], features = rownames(sobj[["ATAC"]])[keep.peaks])

# same is done for the expression assays
keep.genes <- which(rownames(sobj[["RNA"]]) %in% names(gtf))
sobj[["RNA"]] <- subset(sobj[["RNA"]], features = rownames(sobj[["RNA"]])[keep.genes])
keep.genes2 <- which(rownames(sobj[["SCT"]]) %in% names(gtf))
sobj[["SCT"]] <- subset(sobj[["SCT"]], features = rownames(sobj[["SCT"]])[keep.genes2])


# add motif information
# Construct a Motif object containing DNA sequence motif information and add it to an existing Seurat object or ChromatinAssay. 
# If running on a Seurat object, AddMotifs will also run RegionStats to compute the GC content of each peak and store the results in the feature metadata. 
sobj <- AddMotifs(
  object = sobj,
  genome = BSgenome.Hsapiens.UCSC.hg38,        # org-specific
  pfm = pfm,
  assay = "ATAC"
)

# sobj <- AddMotifs(
#   object = sobj,
#   genome = getSeq(BSgenome.Hsapiens.UCSC.hg38, standardChromosomes(BSgenome.Hsapiens.UCSC.hg38)),        # not working
#   pfm = pfm,
#   assay = "ATAC"
# )


```


Identify enriched motifs in differentially accessible peaks per cluster (see results in 'motif_enriched_clusters_atac.xlsx').

```{r atac_motifs_da_peaks, echo=F, message=FALSE, error=F, warning=F}

# FindMotifs function: Find motifs over-represented in a given set of genomic features. 
# Computes the number of features containing the motif (observed) and compares this to the 
# total number of features containing the motif (background) using the hypergeometric test. 
ATAC_DA_PLIM <- 0.05        # p-value threshold
MIN_PEAKS_FOR_ENRICHMENT <- 3 # skip enrichment if less peaks
#####

cat(paste("\nLook for enriched motifs in differentially accessible peaks filtered for p_val_adj <", ATAC_DA_PLIM, "(motif enrichment is skipped if less than", MIN_PEAKS_FOR_ENRICHMENT, "peaks)\t"))

da_enriched_motifs <- list()

for (gp in names(da_groups_atac)) {
  top_da_peaks <- rownames(da_groups_atac[[gp]][da_groups_atac[[gp]]$p_val_adj < ATAC_DA_PLIM, ]) # filter regions by significance
  cat("Finding motifs for:", gp, "(contains", length(top_da_peaks), "differentially accessible peaks after filtering)\n")
  if(length(top_da_peaks)>= MIN_PEAKS_FOR_ENRICHMENT) {
  da_enriched_motifs[[gp]] <- FindMotifs(object = sobj, features = top_da_peaks)
  }
}

# Save results
if(length(da_enriched_motifs)>0) {
  openxlsx::write.xlsx(da_enriched_motifs, file = file.path("report_files", "motif_enriched_clusters_atac.xlsx"))
  saveRDS(da_enriched_motifs, file = file.path("report_files", "R_merged_atac_da_enriched_motifs.RDS"))
}
gc()

```


Identify enriched motifs in differentially accessible peaks per celltype (see results in 'motif_enriched_clusters_atac_celltypes.xlsx').


```{r atac_motifs_da_peaks_by_celltype, echo=F, message=FALSE, error=F, warning=F}

# FindMotifs function: Find motifs over-represented in a given set of genomic features. 
# Computes the number of features containing the motif (observed) and compares this to the 
# total number of features containing the motif (background) using the hypergeometric test. 
ATAC_DA_PLIM <- 0.05        # p-value threshold
MIN_PEAKS_FOR_ENRICHMENT <- 3 # skip enrichment if less peaks
#####

cat(paste("\nLook for enriched motifs in differentially accessible peaks filtered for p_val_adj <", ATAC_DA_PLIM, "(motif enrichment is skipped if less than", MIN_PEAKS_FOR_ENRICHMENT, "peaks)\t"))

da_enriched_motifs_ct <- list()

for (gp in names(da_groups_atac_ct)) {
  top_da_peaks_ct <- rownames(da_groups_atac_ct[[gp]][da_groups_atac_ct[[gp]]$p_val_adj < ATAC_DA_PLIM, ]) # filter regions by significance
  cat("Finding motifs for:", gp, "(contains", length(top_da_peaks_ct), "differentially accessible peaks after filtering)\n")
  if(length(top_da_peaks_ct)>= MIN_PEAKS_FOR_ENRICHMENT) {
    da_enriched_motifs_ct[[gp]] <- FindMotifs(object = sobj, features = top_da_peaks_ct)
  }
}

# Save results
if(length(da_enriched_motifs_ct)>0) {
  openxlsx::write.xlsx(da_enriched_motifs_ct, file = file.path("report_files", "motif_enriched_clusters_atac_celltypes.xlsx"))
  saveRDS(da_enriched_motifs_ct, file = file.path("report_files", "R_merged_atac_da_enriched_motifs_celltypes.RDS"))
}
gc()

```





## Motif activity between clusters

### Per-cell motif activity

Determine motif activity per cell, using `chromVAR` package. Can be used as an alternative method for detecting differential motif activity between clusters.

```{r atac_motif_activities, echo=F, message=FALSE, error=F, warning=F, eval=F}

# Determine motif activity per cell, using `chromVAR` package. 
# The package aims to identify motifs or other genomic annotations associated with variability in chromatin accessibility between individual cells or samples.
# Can be used as an alternative method for detecting differential motif activity between clusters.
# Note that this step can take 30-60 minutes 
# Will return a new Seurat assay with the motif activities (the deviations in chromatin accessibility across the set of regions) as a new assay.

sobj <- RunChromVAR(
  object = sobj,
  genome = BSgenome.Hsapiens.UCSC.hg38,
  assay = "ATAC"
)

```


### Calculate differential motif activity between clusters

Calculate differential motif activity between ATAC clusters.

```{r atac_differential_motif_activities_atac_clusters, echo=F, message=FALSE, error=F, warning=F, eval=F}

ATAC_DA_MINCELLS <- 20        # minimum number of cells to include cluster in analysis

DefaultAssay(sobj) <- "chromvar"

Idents(sobj) <- "Sample_ATACClusters"

grp_counts <- table(sobj$Sample_ATACClusters)

sample_pairs <- combn(sort(unique(sobj$sample)), 2)
motifda_groups_atac <- list()
for (ct in sort(unique(sobj$clusters_atac))) {
  for (sp in 1:ncol(sample_pairs)) {
    grp1 <- paste(sample_pairs[1, sp], ct, sep="_")
    grp2 <- paste(sample_pairs[2, sp], ct, sep="_")
    if (grp1 %in% names(grp_counts) && grp_counts[grp1] >= ATAC_DA_MINCELLS && 
        grp2 %in% names(grp_counts) && grp_counts[grp2] >= ATAC_DA_MINCELLS) {
      group_pair <- paste(grp1, grp2, sep = ".")
      cat("Processing pair: ", group_pair, "\n")
      motifda_groups_atac[[group_pair]] <- FindMarkers(
                                             object = sobj,
                                             ident.1 = grp1,
                                             ident.2 = grp2,
                                             only.pos = TRUE,
                                             mean.fxn = rowMeans,
                                             fc.name = "avg_diff"
                                           )
    }
  }
}
# Add motif names (and IDs) to data frames
motifda_groups_atac <- lapply(motifda_groups_atac, function(x){x$motif.id <- rownames(x); x$motif.name <- unlist(sobj@assays$ATAC@motifs@motif.names)[rownames(x)]; x})

# Save results
if(length(motifda_groups_atac)>0) {
  openxlsx::write.xlsx(motifda_groups_atac, file = file.path("report_files", "motif_diffact_clusters_atac.xlsx"))
  saveRDS(motifda_groups_atac, file = file.path(dirs$rdata, "R_merged_atac_motifda_clusters_atac.RDS"))
}
gc()

DefaultAssay(sobj) <- "ATAC"


```


## Gene Regulatory Networks

Pando leverages multi-modal single-cell measurements to infer gene regulatory networks using a flexible linear model-based framework. By modeling the relationship between TF-binding site pairs with the expression of target genes, Pando simultaneously infers gene modules and sets of regulatory regions for each transcription factor.

The fate and state of a cell is regulated through complex circuits of transcription factors (TFs) converging at regulatory elements to enable precise control of gene expression. Modern single-cell genomic approaches allow the simultaneous profiling of gene expression and chromatin accessibility in individual cells, which opens up new opportunities for the inference of gene regulatory networks (GRNs). Pando jointly utilizes scRNA-seq and scATAC-seq data to infer regulatory relationships between TFs and target genes.

The unifying idea behind many modern GRN inference methods is to model the expression of each gene as a function of TF abundances. The weights or coefficients of this model can then be interpreted as a measure of the regulatory interaction between TF and target gene. Pando tries to generalize this concept to make use of the multi-modal nature of modern single-cell technologies by incorporating TF binding information directly into the model. By utilizing jointly measured or integrated scRNA-seq and scATAC-seq data, Pando models the expression of genes based on the interaction of TF expression with the accessibility of their putative binding site.


```{r pando, echo=F, message=FALSE, error=F, warning=F}

library(Pando)
library(grr)

# Select variable features
sobj <- Seurat::FindVariableFeatures(sobj, assay='SCT')

# Initiate GRN object and select candidate regions. 
# This will create a RegulatoryNetwork object inside the Seurat object 
# and select candidate regulatory regions. By default, Pando will consider 
# all peaks as putative regulatory regions, but the set of candidate 
# regions can be constrained by providing a GenomicRanges object in the 
# regions argument. Pando ships with a set of conserved regions 
# (phastConsElements20Mammals.UCSC.hg38) as well as predicted regulatory 
# elements from ENCODE (SCREEN.ccRE.UCSC.hg38) for the human genome (hg38).
# data('phastConsElements20Mammals.UCSC.hg38')
# data('SCREEN.ccRE.UCSC.hg38') # e.g. use it in initiate_grn as:
# regions = union(phastConsElements20Mammals.UCSC.hg38, SCREEN.ccRE.UCSC.hg38)
# When working with genomes other than human you can use the peaks that are correlated 
# with the expression of nearby genes identified by the Seurat function LinkPeaks (see above).
# Using only these genes is quite strict, as only a small fraction of genes will be linked, 
# but the developers found that this does result in quite robust GRNs. Use as:
# regions = StringToGRanges(Links(sobj[["ATAC"]])$peak)
sobj <- initiate_grn(sobj,
                     regions = NULL, # if specified, intersections with peak ranges from peak_assay are used
                     peak_assay = "ATAC",
                     rna_assay = "SCT",
                     exclude_exons = TRUE) # new object is now called SeuratPlus
# GetGRN(sobj) # get RegulatoryNetwork object 
# regions <- NetworkRegions(sobj) # We can also inspect the candidate regulatory regions that we have selected:
# regions@ranges
# regions@peaks

# Scan candidate regions for TF binding motifs
# This uses motifmatchr to pair up TFs with their putative binding sites. 
# Pando provides a custom motif database (motifs) compiled from JASPAR and CIS-BP, 
# but in principle any PFMatrixList object can be provided here. 
# A data frame with motif-to-TF assignments (motif IDs in 1st column and TF names in 2nd column) 
# can be provided in the motif_tfs argument.
# data(motifs)
# data('motif2tf')
sobj <- find_motifs(
    sobj,
    pfm = pfm,
    genome = BSgenome.Hsapiens.UCSC.hg38,
    motif_tfs = NULL
)
# The Regions object has now gotten a new slot containing the Motif object. 
# This object stores a sparse peak x motif matrix with the matches and some other information.
# regions <- NetworkRegions(sobj)
# regions@motifs@data[1:5,1:5]

# Infer gene regulatory network by fitting regression models for the expression of each gene. 
# Here, we first select regions near genes, either by simply considering a distance 
# upstream and/or downstream of the gene (peak_to_gene_method='Signac') or by also 
# considering overlapping regulatory regions as is done by GREAT (peak_to_gene_method='GREAT')
sobj <- infer_grn(sobj,
                  peak_to_gene_method = 'Signac', # One of 'Signac' or 'GREAT'
                  method = 'glm',
                  genes = NULL, # select a subset of genes that we want to use for GRN inference
                  upstream = 1e+05,
                  downstream = 0,
                  tf_cor = 0.1,
                  peak_cor = 0) 
# GetNetwork(sobj) # access the inferred Network object

# Once the models are fit, model coefficients can be inspected with coef().
# This returns a dataframe coefficients (estimate) and p-values (pval) for each TF/region-target gene pair.
# coef(sobj)

# Module extraction (i.e. the set of genes that are regulated by each transcription factor).
# Based on the model coefficients, we can construct a network between TFs and target genes. 
# This can be further summarized to construct gene and regulatory modules with the set of 
# target genes and regulatory regions for each TF. 
sobj <- find_modules(sobj, p_thresh = 0.05,
                     rsq_thresh = 0.1,
                     nvar_thresh = 10,
                     min_genes_per_module = 5)

# Print modules
modules <- NetworkModules(sobj) # The meta slot holds a dataframe with module information.
kbl(as.data.frame(modules@meta)[1:min(20,nrow(modules@meta)),], align = "l", format="simple", caption="Identified TF modules (i.e. the set of genes that are regulated by each transcription factor, first 20 entries)") %>% kable_styling(full_width = F)
write.table(as.data.frame(modules@meta), file =file.path("report_files", "GRN_TF_modules.txt"), quote = F, row.names = F,  sep="\t")

cat("Plot goodness-of-fit metrics of the fitted models. This shows us the explained variance of the model, as well as the number of variables in each model. We can observe that with more variables, the models will have a better fit. The dashed lines show the applied thresholds for in the find_modules function.\n")
pgof <- plot_gof(sobj, point_size=3) 
pgof
ggsave(plot=pgof, filename="report_files/GRN_goodness_of_fit_metrics.pdf")

cat("Plot size of the modules with respect to the number of target genes as well as the number of peaks and regulating TFs per target gene.\n")
pmm <- plot_module_metrics(sobj) 
pmm
ggsave(plot=pmm, filename="report_files/GRN_module_metrics.pdf")

# create the graph to be visualized and optionally a UMAP embedding for the nodes 
sobj <- get_network_graph(sobj, 
                          rna_assay = "SCT", 
                          graph_name = "module_graph", # we can access the graph with this name later
                          umap_method = c("weighted", "corr", "coef", "none"), # method to compute edge weights for UMAP
                          features = NULL) # plot a smaller subgraph of the GRN by selecting a set of genes as features
cat("Visualization of the network graph. The nodes are colored and sized based on their centrality in the graph and the edges are colored by the direction of the regulation (inhibitory: grey; activating: orange)")
pnetg <- plot_network_graph(sobj, 
                            graph = "module_graph",
                            layout = "umap") + ggtitle("Network graph")
pnetg
ggsave(plot=pnetg, filename="report_files/GRN_network_graph.pdf")


# # Optional: Sometimes it is useful to plot a subgraph of the GRN centered around one TF (e.g. NEUROD4), to reveal a hierarchy of regulation.
# sobj <- get_tf_network(sobj, tf="NEUROD4", graph="module_graph", keep_all_edges=F)
# plot_tf_network(sobj, tf='NEUROD4', circular=T)
# # further custom plotting of dedicated sub graphs if generated
# library(ggraph)
# subgraph <- NetworkGraph(sobj, graph='module_graph')
#  ggraph(subgraph, layout='drl') +
#     geom_edge_hive(aes(color=estimate), size=2, fill='grey') +
#     geom_node_point(aes(size=centrality), shape=21, fill='grey') +
#     geom_node_text(aes(label=name), size=4, shape=21, repel=T) +
#     theme_void()


```



```{r store_data, echo=F, message=FALSE, error=F, warning=F, eval=T}

# store colData in report_files folder (csv file without numerical columns for compatibility with Loupe import)
write.table(sobj[[]][, !sapply(sobj[[]], is.numeric)], file="report_files/cells.csv", sep=",", quote = F, row.names = F)

# store objects of analysis
saveRDS(sobj, file="report_files/sobj.RData")

```



# Used tools and versions for this analysis ##

Read mapping was performed with STAR using the following parameters:

```{r STAR_parameters_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
cat(DEhelper.STARparms(), sep="\n")
``` 

The following tools were used for data processing:

```{r ToolVersions_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
cat(Toolhelper.ToolVersions(), sep="\n")
```

R session info:

```{r R_sessionInfo, echo=F, results='asis', error=F, warning=F, message=F}
sessionInfo()
```

</div>

