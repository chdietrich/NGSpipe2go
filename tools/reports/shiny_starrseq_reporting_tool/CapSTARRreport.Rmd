---
title: "capstarrseq_test"
output:
  html_document:
    toc: true
    toc_float: true
    css: styles.css
---

<div class="contentbox">

```{r Initialise, echo=F, result='hide', error=F, warning=F, message=F}
options(stringsAsFactors=FALSE)
require(rmarkdown)
require(knitr)
require(Cairo)                                                    
knitr::opts_chunk[['set']](dev='CairoPNG')
source('CapSTARR.shinyrep.helpers.R')
loadGlobalVars()
useDiffExp <- SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"
isPaired <- tolower(SHINYREPS_PAIRED) == "yes"
runCutadapt <- SHINYREPS_RUN_CUTADAPT=="true"
SHINYREPS_FASTQC_SUMMARIZED <- as.logical(SHINYREPS_FASTQC_SUMMARIZED)

## parallel pipeline branches
# most modules store results of different pipeline branches in separated sub-directories of the respective output folder. 
# One sub-directory may be "" as default output folder.
# Modules producing output files with names uniquely distinguishable for all branches may be stored in the same output folder. 
# If a subset of these files shall be selected they can be grepped by a character substring
branches <- c(deduplicated="deduplicated", withduplicates="withduplicates") # value is sub-directory, name is file tag in case of subsetting  

if (SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true") {
    # The 'SHINYREPS_DE_DESEQ' file path variable does not contain the branch sub-directories
    deseqdir <- dirname(SHINYREPS_DE_DESEQ)
    deseqRData <- basename(SHINYREPS_DE_DESEQ)
    
    # Read in the various DESeq2 objects from the different branches
    deseq <- lapply(branches, function(dir){
      load(file.path(deseqdir, dir, deseqRData))        # the outcome from the DE analysis
      list("dds" = dds, "rld" = rld, "res" = res, 
           "pairwise.dds" = pairwise.dds, "conts" = conts, 
           "gtf" = gtf, "add_factors" = add_factors)
    })
    names(deseq) <- branches
}

``` 


## Raw reads QC {.tabset .tabset-pills}

The raw sequence reads of all samples are analysed with the popular FastQC tool (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/).


### Read quality

The “read quality” plot summarizes at each read position the Phred quality scores, which are logarithmically related to the base-calling error probabilities. The higher the Phred scores, the better the base calls. The elements of the plot are as follows: the central red line is the median value, the yellow box represents the inter-quartile range (25-75%), the upper and lower whiskers represent the 10% and 90% points, and the blue line represents the mean quality. The background of the graph divides the y-axis into very good quality calls (green), calls of intermediate quality (yellow), and calls of poor quality (red). Typically, the majority of calls on all base positions fall into the green area. Due to binning of quality score in recent sequencing technologies (e.g. Illumina NextSeq), sequencing qualities may be the same on many position and sample profiles may appear very similar.

```{r FastQC_qual_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}

if (SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true") {
    if (SHINYREPS_FASTQC_SUMMARIZED) {
        fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T)
        plot(fastqc_summary_plot$p.qual)
        cat("\n", fill = T)
    } else {
        fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F)
    }
} else {
    if (SHINYREPS_FASTQC_SUMMARIZED) {
        fastqc_summary_plot <- ChIPhelper.Fastqc.custom(web=F,summarizedPlots=T)
        plot(fastqc_summary_plot$p.qual)
        cat("\n", fill = T)
    } else {
        fastqc_summary_plot <- ChIPhelper.Fastqc.custom(web=F,summarizedPlots=F)
    }
}

```

```{r FastQC_qual, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=round((3*fastqc_summary_plot$no.of.samples)/4)+1}

if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
}

```


### Sequence bias

The "sequence bias" plot shows the proportion of each base (% T, C, A and G) at each position. In a random library there would be little difference between the positions of a sequence run, so the lines in this plot should run parallel with each other. But most RNA-seq libraries show sequence imbalance in the first 10-12 read positions due to RT priming biases, which should however look fairly similar in all samples. In case the nucleotide content is summarized in a heatmap for all samples, gray colored fields represent a balanced nucleotide content.


```{r FastQC_nuc_content_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}

if (SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true") {
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  } else {
      fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F)
  }
} else {
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  } else {
      fastqc_summary_plot <- ChIPhelper.Fastqc.custom(web=F,summarizedPlots=F)
  }
}

```

```{r FastQC_nuc_content, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=round((3*fastqc_summary_plot$no.of.samples)/4)+1}

if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
}

```


### GC content

The "GC content" plot shows the GC% distribution of all reads and all samples. Typically, the lines should tightly overlap and look essentially the same in all samples. An unusually shaped distribution could indicate a contaminated library.

```{r FastQC_GC, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}

plot(fastqc_summary_plot$p.gc)
cat("\n", fill = T)

```


```{r cutadapt, echo=F, results='asis', error=F, warning=F, message=F, eval=SHINYREPS_RUN_CUTADAPT=="true"}
cat("## Adapter trimming with Cutadapt\n")
cat("\nThe following plot shows the amount of reads trimmed (in percent) for the selected adapter sequences. The column 'tooshort' gives the percentage of reads removed due to the minimum length threshold after trimming. Additionally to the column 'trimmed' which is for all adapters combined, there are columns for every single adapter giving the percentage of reads trimmed for this adapter.\n\n")

DEhelper.cutadapt()
```

```{r FastQC_qual_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=SHINYREPS_RUN_CUTADAPT=="true"}
cat("### FastQC of trimmed reads QC {.tabset}\n\n")
cat("#### Read quality\n\n")
if (SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true") {
    if (SHINYREPS_FASTQC_SUMMARIZED) {
        fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T, subdir="trimmed")
        plot(fastqc_summary_plot$p.qual)
        cat("\n", fill = T)
    } else {
        fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F, subdir="trimmed")
    }
} else {
    fastqc_summary_plot <- ChIPhelper.Fastqc.custom(web=F,summarizedPlots=SHINYREPS_FASTQC_SUMMARIZED,
                                                    metrics=c("BaseQuals", "SeqContent", "GcContent", "DupLevels"))
}
```

```{r FastQC_qual_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=SHINYREPS_RUN_CUTADAPT=="true"}

if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
}
```

```{r FastQC_nuc_content_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, ceiling(0.12*fastqc_summary_plot$no.of.samples)+1), eval=SHINYREPS_RUN_CUTADAPT=="true"}
cat("#### Sequence bias of trimmed reads\n")

if (SHINYREPS_FASTQC_SUMMARIZED) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
} 
```

```{r FastQC_nuc_content_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=SHINYREPS_RUN_CUTADAPT=="true"}

if (SHINYREPS_FASTQC_SUMMARIZED == F) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
}
```

```{r FastQC_GC_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=SHINYREPS_RUN_CUTADAPT=="true"}
cat("#### GC content of trimmed reads\n")
fastqc_summary_plot$p.gc
cat("### {-}\n", fill = T)
```

## {-}

## Read mapping {.tabset .tabset-pills}

Mapping to the reference genome was done using the established NGS mapping tool Bowtie2 (http://bowtie-bio.sourceforge.net/bowtie2). While STARR-seq data are derived from mRNA, they are short contiguous inserts without introns, so a DNA mapper like Bowtie2 is suitable for such data.

```{r Bowtie2_paragraph, echo=F,results='asis',error=F,warning=F,message=F}
# mapping statistics for either paired end or single read design

if(SHINYREPS_PAIRED == "yes") {cat(" The mapping statistics show the total number of reads delivered to the aligner ('all pairs'), the number of read mapping concordantly to one location ('unique'), the number of read pairs mapping concordantly to multiple locations ('multi'), the number of read pairs mapping discordantly to one location ('discordantly'), the number of reads pairs where only one reads maps to one location ('single unique'), the number of read pairs where only one read maps to multiple locations ('single multi') and the overall alignment rate (this is based on the amount of pairs aligned, read pairs in which only one read is mapped are taken into account as half a pair). Percentages are based on the amount of pairs sequenced ('all pairs').

A read pair that aligns with the expected relative mate orientation (typically 'fr') and with the expected range of distances between mates (typically up to 1 kb) is said to align 'concordantly'. If both mates have unique alignments, but the alignments do not match paired-end expectations, the pair is said to align 'discordantly'. If Bowtie2 cannot find a paired-end alignment for a pair, by default it will search for unpaired alignments of the respective read mates. For most ChIP-seq-like experiments, as well as (Cap)STARR-seq, discordant and multi-mapping reads are typically discarded in downstream analyses.\n\n")
  
  } else {
    
    cat(" The mapping statistics show the total number of reads delivered to the aligner ('all reads'), the number of reads mapping uniquely to one location ('unique'), the number of reads mapping to multiple locations ('multi') and the overall alignment rate. Percentages are based on the amount of reads sequenced ('all reads').\n\n")
}
  cat(DEhelper.Bowtie2(),sep="\n")
```

## {-}

## Potential contaminants and rRNA content ##

A competitive mapping to the reference genome and known rRNAs (H. sapiens, M. musculus, C. elegans, D. melanogaster, D. rerio, X. tropicalis) as well as frequently occurring Mycoplasma species (M. arginini, M. fermentans, M. hominis, M. hyorhinis, M. orale, and Acholeplasma laidlawii), PhiX and ERCC spike-in sequences, E. coli and B. taurus (bovine) was performed with FastQScreen (http://www.bioinformatics.babraham.ac.uk/projects/fastq_screen/).

In the following plot only relevant contaminants are shown. A contaminant is considered relevant if it consumes `r SHINYREPS_FASTQSCREEN_PERC`% of reads or more in at least one sample. The "one genome" label refers to the amount of reads mapping to that genome only, no matter if they are mapping uniquely or multiple times. The "multiple genomes" label refers to the amount of read mapping to this genome but also to other genomes in the screening regardless of whether they are uniquely or multi-mapping. 

```{r fastqscreen_paragraph, echo=F, results='asis', fig.width=10, error=F, warning=F, message=F}
if (SHINYREPS_CAPSTARRSEQ_DIFFEXP == "true") {
  fastqscreen_plots <- DEhelper.fastqscreen(perc.to.plot=SHINYREPS_FASTQSCREEN_PERC)
} else {
  fastqscreen_plots <- ChIPhelper.fastqscreen(perc.to.plot=SHINYREPS_FASTQSCREEN_PERC)
}
```

```{r fastqscreen_paragraph2, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=(round((3*fastqscreen_plots$no.of.genomes)/4)+1)*fastqscreen_plots$no.of.samples/8+1}
  if(is.null(fastqscreen_plots$errortext)) {
    plot(fastqscreen_plots$p.category.wrap)
  } else {
    cat(fastqscreen_plots$errortext)
  }
```


## UCSC genome browser tracks ##

The browser tracks are generated using bamCoverage tool in [deepTools](https://deeptools.readthedocs.io/en/develop/) and they are normalized using the Counts Per Million mapped reads (CPM) method.


To view the tracks in the UCSC Genome Browser, navigate to the [UCSC Genome Browser Track Hub page](https://genome-euro.ucsc.edu/cgi-bin/hgHubConnect) and enter the following line into the `URL` field:

```{r Trackhub, echo=F, results='asis', error=F, warning=F, message=F}
cat(DEhelper.Trackhub(), sep="\n")
```


## Insert size (for paired-end sequencing) ##

The insert size is defined as the distance between the left-most mapping position of a read and the right-most mapping position of its mate. For DNA, this exactly represents the fragment length. However, in case of RNA, the estimated insert size can be a lot larger than the true insert size / fragment length, when e.g. the read pair overlaps introns or skipped exons. Thus, the insert size calculation can only be seen as a rough estimate of the true insert size / fragment length when looking at RNAseq data.

```{r echo=F, error=F, fig.width=15, message=FALSE, warning=FALSE, results='asis'}

insert <- lapply(branches, function(dir) {
  if(length(branches)>1) {cat(paste("\n\n### Insert size metrics for bam files from", if(dir==""){"default"} else {dir}, "pipeline branch\n\n"))}

  if (!file.exists(file.path(SHINYREPS_INSERTSIZE, dir))) {
  	cat("Insert size data not available.\n")
  } else {
    
    if (SHINYREPS_CAPSTARRSEQ_DIFFEXP == "true") {
        cat(DEhelper.insertsize(subdir=dir), sep="\n")
        p <- DEhelper.insertsize.plot(subdir=dir)
        DEhelper.subchunkify(p, 
                             fig_height = dim(p)[1] * 15/dim(p)[2],
                             fig_width = 15)
    } else {
      cat(ChIPhelper.insertsize(subdir=dir), sep="\n")
      p <- ChIPhelper.insertsize.plot(subdir=dir)
      ChIPhelper.subchunkify(p, 
                             fig_height = dim(p)[1] * 15/dim(p)[2],
                             fig_width = 15)

    }
  }
})

```


## Library complexity assessment ##

Measuring the fraction of duplicated reads is commonly used to control for excessive PCR over-amplification during library preparation and/or for suboptimal amount of input material. However, in RNA-seq duplicated reads may also arise naturally due to the highly expressed (e.g. housekeeping) genes, which makes the overall read duplication rate useless. The IMB-developed tool dupRadar (http://bioconductor.org/packages/release/bioc/html/dupRadar.html) gives an informative insight into the duplication problem by graphically relating the gene expression levels and the observed duplication rates. Thus, problematic samples can be easily identified by visual inspection. Good quality samples with high library complexity show a sigmoidal curve with low duplication rates of weakly expressed genes (below 100 reads/kbp).

```{r Dupradar_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
if (SHINYREPS_CAPSTARRSEQ_DIFFEXP == "true") {
  cat(DEhelper.dupRadar(web=F), sep="\n")
} else {
  cat(ChIPhelper.dupRadar(web=F), sep="\n")
}
```


## Mapped reads annotation ##

The mapped reads were assigned to annotated features (gene exons) using the Subread tool featureCounts (http://bioinf.wehi.edu.au/featureCounts). The unassigned reads are due to ambiguity (overlap with multiple features), non-unique mapping (multimap) or because no overlap is found with known exonic features (e.g. intronic reads derived from unprocessed transcripts). Typically, mRNA-seq with polyA-selection results in more exon-assigned reads compared to total RNA-seq with rRNA-depletion. 

```{r Subread_paragraph, echo=F, results='asis', error=F, warning=F, message=F}

if (SHINYREPS_CAPSTARRSEQ_DIFFEXP == "true") {
  subread <- lapply(branches, function(dir) {
    if(length(branches)>1) {cat(paste("\n\n### Mapped reads annotation from", if(dir==""){"default"} else {dir}, "pipeline branch\n\n"))}
    cat(DEhelper.Subread(subdir=dir), sep="\n")
  })
} else {
  subread <- lapply(branches, function(dir) {
    if(length(branches)>1) {cat(paste("\n\n### Mapped reads annotation from", if(dir==""){"default"} else {dir}, "pipeline branch\n\n"))}
    cat(ChIPhelper.Subread(subdir=dir), sep="\n")
  })
}

```


## Sample relatedness {.tabset .tabset-pills}

### Sample similarity (PCA)

The plot below depicts sample similarity based on priniciple component analysis (PCA) with the 500 genes showing the highest variance. Overall, replicates are expected to show relatively small distances between them, while sample groups often show higher distances between them, depending on the magnitude of expression changes. If the samples cluster other than by group, there might be sample prep batch effects or some other unaccounted biological/technical factors in the experiment. 

```{r MDSplot_paragraph, echo=F, error=F, warning=F, message=F, fig.align="center", out.width="100%", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
deseq2_mds <- lapply(branches, function(branch){
  if(length(branches)>1) {cat(paste("\n\n### MDS plot from", branch, "pipeline branch\n\n"))}
  DEhelper.DESeq2.MDS(dds=deseq[[branch]]$dds, rld=deseq[[branch]]$rld)        # sample MDS 
})        
```

### Sample similarity (clustogram)

A heatmap clustogram of the Euclidean distances between the samples gives an intuitive measure of sample similarity:

```{r Heatmap2_paragraph, echo=F, error=F, warning=F, message=F, fig.align="center", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
deseq2_heatmap_samples <- lapply(branches, function(branch){
  if(length(branches)>1) {cat(paste("\n\n### Sample-to-sample heatmap from", branch, "pipeline branch\n\n"))}
  DEhelper.DESeq2.heatmap(dds=deseq[[branch]]$rld, gtf=deseq[[branch]]$gtf, type="distance")         # heatmap of sample to sample distances
})        
```

### Most variable regions

Additionally, hierarchical clustering of the samples based on the most variable genes reveals replicate consistency and can spot batches of samples related by other characteristics rather than condition:

```{r Heatmap1_paragraph_sd, echo=F, error=F, warning=F, message=F, fig.align="center", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
deseq2_heatmap_mvg <- lapply(branches, function(branch){
  if(length(branches)>1) {cat(paste("\n\n### Most variable regions heatmap from", branch, "pipeline branch\n\n"))}
  DEhelper.DESeq2.heatmap(dds=deseq[[branch]]$rld, gtf=deseq[[branch]]$gtf, type="cluster_sd")   # heatmap of top variant 'n' genes of the rlog transformed counts (normalized and stabilized)
})        
```

### Regions highest avg expression

Finally, a hierarchical clustering of the samples based on the genes with the highest average expression level:

```{r Heatmap1_paragraph_mean, echo=F, error=F, warning=F, message=F, fig.align="center", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
deseq2_heatmap_highexpr <- lapply(branches, function(branch){
  if(length(branches)>1) {cat(paste("\n\n### Highest avg expression regions heatmap from", branch, "pipeline branch\n\n"))}
  DEhelper.DESeq2.heatmap(dds=deseq[[branch]]$rld, gtf=deseq[[branch]]$gtf, type="cluster_mean")    # heatmap of top variant 'n' genes of the rlog transformed counts (normalized and stabilized)
})        

```

## {-}

## Differential gene expression analysis

Pairwise differential expression analysis on the gene level between the experimental groups is performed with the popular R/Bioconductor package DESeq2 (https://bioconductor.org/packages/release/bioc/html/DESeq2.html). Default DESeq2 analysis includes an independent filtering procedure for lowly expressed genes which is meant to ameliorate the multiple testing problem thereby maximising the statistical power to detect differentially expressed genes (DEGs). In this standard analysis only uniquely mapped reads are taken into account to avoid "cross-talk" between different genes. 

Note that by default a standard DESeq2 analysis uses only a statistical (FDR) filter and is thus testing for evidence that the expression changes between two sample groups is different from zero. Performing post-hoc filtering of the results by effect size (fold-change) is not recommended by the software developers and should be avoided. Such a "Volcano plot" gene filtering approach may result in inflated false discovery rates as reported in https://doi.org/10.1093/bib/bbab053. If desirable, the differential expression analysis can incorporate an additional fold-change (FC) threshold directly in the DESeq2 statistical testing model, which results in more conservative but accurate DEG estimates.

For the analyses below, the FDR filter was set to `r SHINYREPS_DE_DESEQ_FDR` and the effect size (FC) filter was set to `r SHINYREPS_DE_DESEQ_FC` (note: FC=1 means no fold-change filter was used).

```{r DifferentialExpression_paragraph, echo=F, results='asis', error=F, warning=F, message=F, fig.align="center", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
fdr <- as.numeric(SHINYREPS_DE_DESEQ_FDR)
FC  <- as.numeric(SHINYREPS_DE_DESEQ_FC)
deseq2_diffexpr <- lapply(branches, function(branch){
  for(i in 1:nrow(deseq[[branch]]$conts)) {

    # subsection
    cont.name <- deseq[[branch]]$conts$contrast.name[i]
    cat("### ", cont.name, " {.tabset .tabset-pills}", fill=T)
    cat("\n", fill=T)

    # pairwise PCA plots
    cat("#### PCA plot, branch: ", branch, fill=T)
    cat("Prinicipal component analysis (PCA) plot using only the samples of the two analysed groups:\n", fill=T)
    DEhelper.DESeq2.pairwisePCA(i, pairwise.dds=deseq[[branch]]$pairwise.dds)
    cat("\n", fill=T)

    # sample to sample distance
    cat("#### Sample-sample dist, branch: ", branch, fill=T)
    DEhelper.DESeq2.heatmap(i, dds=deseq[[branch]]$pairwise.dds, gtf=deseq[[branch]]$gtf,  logTransform=T, type="distance")
    cat("\n", fill=T)

    # most variable genes
    cat("#### Most variable genes, branch: ", branch, fill=T)
    DEhelper.DESeq2.heatmap(i, dds=deseq[[branch]]$pairwise.dds, gtf=deseq[[branch]]$gtf,  logTransform=T, type="cluster_sd")
    cat("\n", fill=T)

    # MA plot
    cat("#### MA plot, branch: ", branch, fill=T)
    genes <- DEhelper.DESeq2.DEgenes(i, res=deseq[[branch]]$res)
    #filtering for tested genes
    genes <- genes[!is.na(genes$padj), ]
    cat("MA plot showing expression fold change on log2 scale vs. mean expression level of all annotated genes. There are", 
        sum((genes$padj < fdr) & (abs(genes$log2FoldChange) > log2(FC)), na.rm=T), "genes with a minimal FC of", FC, "highlighted in the MA plot with corrected pvalue (Benjamini and Hochberg, FDR) <", fdr, ".", "\n")
    #we do not need an additional filter for the FC here
    #since only genes with a minimal fold change of FC are
    #significant for the significance level chosen in the analysis
    DEhelper.DESeq2.MAplot(i, fdr, res=deseq[[branch]]$res, conts=deseq[[branch]]$conts)    # should be fine at taking the value from the UI slider
    cat("\n", fill=T)

    # Volcano plot
    cat("#### Volcano plot, branch: ", branch, fill=T)    
    cat("Volcano plot of all DESeq2-tested genes depicting their expression fold change vs. statistical significance. Differentially expressed genes are highlighted in red and the top 25 are labelled.", "\n", "\n")
    DEhelper.DESeq2.VolcanoPlot(res=deseq[[branch]]$res, i, fdr, web=F)
    cat("\n", fill=T)

    # and DE table
    genes <- DEhelper.DESeq2.DEgenes(i, res=deseq[[branch]]$res)
    #filtering for tested genes
    genes <- genes[!is.na(genes$padj), ]
    cat("#### Top hits, branch: ", branch, fill=T)
    cat("", fill=T)
    cat("The table below shows the top 25 DEGs with their mean normalised counts (baseMean), expression change (log2FoldChange) and statistical significance (padj = FDR-adjusted p-value). The complete DESeq2 results table including FPKM-normalised expression data for all genes in each sample is available in CSV and Excel format in the 'DE_DESeq2' results folder.", fill=T)
    cat("", fill=T)
    genes$baseMean       <- round(genes$baseMean, 2)
    genes$log2FoldChange <- round(genes$log2FoldChange, 2)
    genes$padj           <- format(genes$padj, digits=3, scientific=TRUE)
    cols <- c("gene_name", "baseMean", "log2FoldChange", "padj")
    cat(kable(genes[1:25, cols], row.names=T, align="r", format="markdown"), sep="\n")    # show only the top 25 genes
    cat("", fill=T)

    cat("### {-}\n", fill=T)
  }
})
```


## Chromosome over-representation analysis ##

In some experiments it is possible that there is local effect in gene expression due to for instance genetic linkage. One hint that this might be happening is if there are more affected genes in a chromosome than expected by chance. If this happens, further data exploration might be warranted. 

The tables contain a summary of the likelihood that there are more DE genes in a particular chromosome than expected by chance. The p-value is calculated with Fisher's exact test and corrected for multiple testing (FDR). Only chromosomes which show a significant over-representation (FDR < 0.1) are presented in this table. This test also gives an odds ratio which represents the strength of association. The odds ratio compares the number of DE genes found on chromosome A with its expected number. If an odds ratio is equal to or less than 1, there is no association between the two lists. If the odds ratio is much larger than 1, then the association is strong. The class also calculates the Jaccard index which measures the similarity between two lists of genes. Here, it is comparing the list of DE genes on a chromosome A with the list of genes, which are either DE and/or on chromosome A. The Jaccard index varies between 0 and 1, with 0 meaning there is no similarity between the two and 1 meaning the two are identical.


```{r ChromosomeEnrichment_paragraph, echo=F, results='asis', error=F, warning=F, message=F, fig.align="center", eval=SHINYREPS_CAPSTARRSEQ_DIFFEXP=="true"}
fdr <- as.numeric(SHINYREPS_DE_DESEQ_FDR)
deseq2_chromEnrich <- lapply(branches, function(branch){
  for(i in 1:nrow(deseq[[branch]]$conts)) {

    # subsection
    cont.name <- deseq[[branch]]$conts$contrast.name[i]
    cat("### ", cont.name, ", branch: ", branch, fill=T)    
    cat("", fill=T)
    
    # and DE table
    table_fisher <- DEhelper.DESeq2.ChrOverrepresentation(res=deseq[[branch]]$res, i, fdr)

    if (nrow(table_fisher) > 0) {
        cat(kable(table_fisher, row.names=T, align="r", format="markdown"), sep="\n")
        cat("", fill=T)
    } else {
        cat("No chromosome over-representation found.", fill=T)
        cat("", fill=T)
    }
  }
})
```


## Used tools and versions for this analysis ##

The following tools were used for data processing:

```{r ToolVersions_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
cat(Toolhelper.ToolVersions(), sep="\n")
```

</div>


